= Библиотека KDDD
Tepex <tepex@mail.ru>
1.0, 29/V-2025
:source-highliter: rouge
:mmdc: ./node_modules/.bin/mmdc

Kotlin DDD (KDDD) — библиотека корневых типов для построения иерархии собственных типов данных доменного уровня на языке Котлин в соответствии с тактическими патернами `DDD` — `Entity` и `Value Object`. Состоит из закрытой *ФСТ*, аннотаций и регламента построения *CDT*.

== Мотивация
Котлин является языком программирования общего назначения, предоставляющий очень широкие возможности для разработчика. В частности — для проектирования собственных структур данных. К сожалению, такая широта зачастую оборачивается появлением порочных практик, таких как мутабельность публичных свойств, одержимость примитивами (primitive obsession) и др.

Для борьбы с этим возникает необходимость в наличии:

- базовой системы типов в качестве родительской корневой, котрая бы отражала концепцию стратегических патернов `DDD`  — `Entity` и `Value Object`, и в том числе определяла бы валидацию при создании  *CDT* и его поведение;
- регламенте, который бы задавал правила формирования *CDT* и ограничения, и на основе которого можно было бы создавать отдельные инструменты валидации кода и линтеры.

== Цель
- Создание библиотеки закрытой *ФСТ*, как основы для построения пользовательской *ФСТ* для предметной области *Пользователя*.
- Создание регламента проектирования *CDT*.

== Типы *Kddd*
Интерфейсы *Kddd* наследуются от корневого sealed-интерфейса `Kddd` у которого имеется метод `validate()` предназначенный для валидации типа при его создании.

=== `IEntity : Kddd`
Определяет тактический _DDD_-патерн _Entity_. Содержит поля:

- `id` идентичность сущности.
- `content` _Value Object_ содержимого сущности.

*Регламент* требует, что реализация этого интерфейса должна переопределить контракт `hashCode()/equals()`, завязав их на поле `id`. Отдельная группировка свойств сущности в свойство `content` обусловлена подходом, обоснованным у https://enterprisecraftsmanship.com/posts/nesting-value-object-inside-entity/[Вдадимира Хорикова].

=== `ValueObject : Kddd`
Определяет тактический _DDD_-патерн _Value Object_. Sealed-интерфейс со следующими наследниками:

==== `ValueObject.Data`
Предназначен для проектирования *CDT* с несколькими свойствами и последующей имплементации *CDT* в виде `data class`. Содержит метод `<T: Kddd, A: Kddd> fork(vararg args: A): T` для возможности копирования объекта этого типа и аналогичен методу `copy()` у `data class`. Реализация этого метода описана в *Регламенте*.

==== `ValueObject.Value<BOXED: Any>`
Предназначен для проектирования *CDT* с одним свойством и последующей имплементации *CDT* в виде `value class`. Тип свойства определяется параметризованным типом `BOXED` и может быть либо примитивным типом Котлин (`String`, `Int` и т.д.), либо типом общего назначения (`File`, `UUID` и т.п.). Обусловлено борьбой с _одержимостью примитивами_. Содержит метод `<T : Value<BOXED>> fork(boxed: BOXED): T` для возможности копирования объекта этого типа и аналогичен методу `copy()` у `data class`. Реализация этого метода описана в *Регламенте*.

Необходимость включения метода `fork` в контракты интерфейсов `ValueObject` обеспечивает возможность создания функционала/операций над этими типами на этапе декларации интерфейсов.

****
.Пример спроектированного *CDT* для моделирования точки с двумя координатами.
[source,kotlin]
----
public interface Point : ValueObject.Data {
    public val x: Coordinate
    public val y: Coordinate

    override fun validate() {
        // Здесь можно задать границы модели и провалидировать консистентность свойств.
        check(x.boxed in 0..1000)
        check(y.boxed in 0..1000)
    }

    public operator fun plus(other: Point): Point =
        fork(x + other.x, y + other.y)

    public operator fun minus(other: Point): Point =
        fork(x - other.x, y - other.y)

    public operator fun times(other: Point): Point =
        fork(x * other.x, y * other.y)

    public interface Coordinate : ValueObject.Value<Int> {
        override fun validate() {}

        public operator fun plus(other: Coordinate): Coordinate =
            fork(boxed + other.boxed)

        public operator fun minus(other: Coordinate): Coordinate =
            fork(boxed - other.boxed)

        public operator fun times(other: Coordinate): Coordinate =
            fork(boxed * other.boxed)
    }
}
----
Также в этом интерфейсе можно определить, например, метод расчета расстояния до другой точки или вынести такой функционал этой модели в функцию-расширение как _use case_.
****

== Регламент
Слова «MUST», «MUST NOT», «REQUIRED», «SHALL», «MAY» и «OPTIONAL» в нижеследующих списках должны интерпретироваться как определено в https://www.ietf.org/rfc/rfc2119.txt[RFC 2119].

=== Правила проектирования интерфейсов *CDT*
Интерфейс *CDT*:

. Должен (MUST) наследоваться от соответствующего подтипа *Kddd*.
. Свойства должны (MUST) быть с модификатором `val`. Мутабельность осуществляется через метод `fork`.
. Свойства должны (MUST) быть типом *CDT*, либо коллекциями с параметризованными типами [TODO: еще и `enum`].
. Параметризованные типы должны (MUST) быть быть типом *CDT*, либо коллекциями с параметризованными типами. Таким образом возможна вложенность, например: `List<Map<CDT, Set<CDT>>>` и т.д.
. Типы свойств могут (MAY) быть определены в отдельном *CDT*, либо внутри данного интерфейса (_nested_).
. Должен (SHOULD) [TODO: пояснить, почему именно 'SHOULD'] переопределять метод `validate()`. Может быть пустым при отсутствии валидации. Логика валидации должна выкидывать исключение `IllegalStateException` в случае непрохождения проверки.
. Может (MAY) содержать методы, декларирующие функционал модели.
. Может (OPTIONAL) предваряться `KDDD`-аннотациями.

=== Правила имплементации интерфейсов *CDT*
Проектируемые типы

. Наследоваться от типов `Kddd`.
. Реализовывать метод `validate()` интерфейса `Kddd` который будет вызываться перед созданием объекта. В нем пишется логика проверки валидности свойств и параметров и выкидывается `IllegalStateException` в случае непрохождения проверки. Метод `validate()` может быть пустым.
. Свойства `ValueObject.Data` должны быть наследниками типа `Kddd`.
. Тип параметра `ValueObject.Value.boxed` может быть либо примитивом (`String`, `Int` и т.д.), либо типом общего назначения (`File`, `UUID` и т.д.).
. TODO: описать применение аннотаций

[glossary]
== Термины и определения
Пользователь:: Разработчик, использующий данную библиотеку для проектирования собственных типов (*CDT*) для некоторого своего домена.
ФСТ:: Формальная система типов, построенная на заданной аксиоматике — постулатах, определяющих допустимые границы значений и операции над типами.
Kddd:: Корневой тип библиотеки `KDDD`.
CDT:: Customer Domain Type — собственный тип (интерфейс) структуры данных, который проектирует *Пользователь*.
