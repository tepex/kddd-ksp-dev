= Библиотека KDDD
Tepex <tepex@mail.ru>
1.0, 29/V-2025
:source-highliter: rouge
:mmdc: ./node_modules/.bin/mmdc
:toc:
:toc-title: Содержание

KDDD (Kotlin DDD) — библиотека базовых типов, предназначенная для построения <<domain-model,моделей предметных областей>> на языке Котлин согласно с тактическими _DDD_-патернами — _Entity_ и _Value Object_. Состоит из закрытой <<fst,*ФСТ*>>, аннотаций и регламента построения <<cdt,*CDT*>>.

== Мотивация
[quote,Закон Е. А. Седова]
В сложной иерархически организованной системе рост разнообразия на верхнем уровне обеспечивается ограничением разнообразия на предыдущих уровнях, и наоборот, рост разнообразия на нижнем уровне разрушает верхний уровень организации (то есть, система как таковая гибнет).

Котлин является языком программирования общего назначения, предоставляющий очень широкие возможности для разработчика. В частности, — для проектирования собственных структур данных (типов). К сожалению, такая широта зачастую оборачивается появлением порочных практик, таких как мутабельность публичных свойств, одержимость примитивами (_primitive obsession_), нарушениями принципов _SOLID_ и пр.

При проектировании <<domain-model,*МПО*>> необходимо создать собственную <<fst,*ФСТ*>> с  обусловленными бизнес-требованиями правилами и ограничениями, возможностью валидации объектов при их создании, покрытию юнит-тестами логики <<domain-model,*МПО*>>. В свою очередь такая <<fst,*ФСТ*>> должна создаваться в рамках аксиоматики базовой <<fst,*ФСТ*>> высшего уровня, как основы, и которая бы воплощала концепцию тактических _DDD_-патернов — _Entity_ и _Value Object_.

Ограничения должны применяться на самых ранних этапах. Отчасти это возможно решить на уровне компиляции путем создания контрактов (абстрактых методов) в базовых интерфейсах и проверкой их логики юнит-тестами. Отчасти — наличием регламента, задающим эти ограничения. Проверка соблюдения регламента может осуществляться за счет дополнительных инструментов автоматизации: валидаторы кода, линтеры, кодогенераторы.

== Цель
- Создание закрытой базовой <<fst,*ФСТ*>>, воплощающую концепцию тактических _DDD_-патернов.
- Обеспечение механизма валидации <<cdt,*CDT*>> при создании объектов.
- Создание регламента проектирования <<cdt,*CDT*>>.

[#types]
== Базовая *ФСТ*
Интерфейсы <<kddd,*Kddd*>> наследуются от корневого sealed-интерфейса `Kddd` который имеет метод `validate()` предназначенный для валидации объектов при их создании. В переопределенных методах `validate()` должна реализовываться логика валидации объекта и выкидываться исключение `IllegalStateException` в рамках этой логики.

=== `IEntity : Kddd`
Определяет тактический _DDD_-патерн _Entity_. Содержит поля:

- `id` — идентичность сущности.
- `content` — _Value Object_ содержимого сущности.

<<regulation,*Регламент*>> требует, что реализация этого интерфейса должна переопределять контракт `hashCode()/equals()`, завязав их на поле `id`. Отдельная группировка свойств сущности в свойство `content` обусловлена подходом, обоснованным у https://enterprisecraftsmanship.com/posts/nesting-value-object-inside-entity/[Вдадимира Хорикова].

=== `ValueObject : Kddd`
Определяет тактический _DDD_-патерн _Value Object_. Sealed-интерфейс со следующими наследниками:

==== `ValueObject.Data`
Предназначен для проектирования <<cdt,*CDT*>> с несколькими свойствами и последующей имплементации <<cdt,*CDT*>> в виде `data class`. Декларирует метод `<T: Kddd, A: Kddd> fork(vararg args: A): T` для возможности копирования объекта этого типа и аналогичен методу `copy()` у `data class`. Реализация этого метода описана в <<regulation,*Регламенте*>>.

==== `ValueObject.Value<BOXED: Any>`
Предназначен для проектирования *CDT* с одним свойством и последующей имплементации <<cdt,*CDT*>> в виде `value class`. Тип свойства определяется параметризованным типом `BOXED` и может быть либо <<pt,*ПТ*>>, либо <<ct,*ТОН*>>. Обусловлено борьбой с _одержимостью примитивами_. Декларирует метод `<T : Value<BOXED>> fork(boxed: BOXED): T` для возможности копирования объекта этого типа и аналогичен методу `copy()` у `data class`. Реализация этого метода описана в <<regulation,*Регламенте*>>.

Метод `fork()` в контрактах интерфейсов `ValueObject` призван обеспечить возможность создания функционала/операций над этими типами на этапе декларации интерфейсов и, соответственно, компиляции, что обеспечивает возможность сразу создавать и запускать юнит-тесты с соответств прежде, чем будут .

[#annotations]
== Аннотации
- `KDGeneratable`
- `KDParsable`
- `KDIgnore`

[#regulation]
== Регламент
IMPORTANT: Слова «*MUST*», «*MUST NOT*», «*REQUIRED*», «*SHALL*/*SHOULD*», «*MAY*» и «*OPTIONAL*» в нижеследующих списках понимаются как определено в https://www.ietf.org/rfc/rfc2119.txt[RFC 2119].

<<cdt,*CDT*>> может быть реализован двумя способами:

. Опосредовано через интерфейс-наследник <<kddd,*Kddd*>> и последующей имплементацией в классе.
. Непосредственно как класс-наследник <<kddd,*Kddd*>>.

Первый вариант крайне рекомендуется, т.к. разделение абстракции и имплементации удобно своей гибкостью, использованием _Dependency Injection_, юнит-тестированием и, самое главное, — возможностью кодогенерации имплементации.

=== Интерфейс *CDT*
Тип <<cdt,*CDT*>> (`Cdt`):

. Должен быть (*MUST*) `interface`.
. Должен (*MUST*) наследоваться от соответствующего подтипа <<kddd,*Kddd*>>.
. Свойства не должны быть (*MUST NOT*) мутабельными, быть: `val`. Мутабельность осуществляется через метод `fork()`.
. Свойства могут быть (*MAY*) нуллабельными.
. Если родительский тип `ValueObject.Data`:
[arabic]
.. Свойства должны быть (*MUST*) типом <<cdt,*CDT*>>, либо коллекциями (`Set`, `List`, `Map`) [TODO: еще и `enum`].
.. Параметризованные типы коллекций должны быть (*MUST*) типом <<cdt,*CDT*>>, либо коллекциями с параметризованными типами. Таким образом возможна вложенность коллекций, например: `List<Map<Cdt, Set<Cdt>>` и т.д.
.. Типы свойств могут быть (*MAY*) определены в отдельном <<cdt,*CDT*>>, либо внутри данного типа (_nested_).
. Если родительский тип `ValueObject.Value<BOXED : Any>`:
[arabic]
.. Параметризованный тип должен быть (*MUST*) либо <<pt,*ПТ*>>, либо <<ct,*ТОН*>>.
. Должен (*SHOULD*) переопределять метод `validate()`, который будет вызываться перед созданием объекта. В нем пишется логика проверки валидности свойств и параметров и выкидывается `IllegalStateException` в случае непрохождения проверки. Может быть (*MAY*) пустым, если логика валидации не задана.
. Может (*MAY*) содержать методы, декларирующие/реализующие функционал модели.
. Может (*OPTIONAL*) предваряться `KDDD`-аннотациями.

=== Имплементация *CDT*
Тип <<cdt,*CDT*>> (`CdtImpl`):

. Должен быть (*MUST*) классом-наследником типов <<kddd,*Kddd*>> прямо или опосредовано через интерфейс <<cdt,*CDT*>>.
. Должен иметь (*MUST*) приватный конструктор. Объект класса создается через билдер.
. Должен (*MUST*) вызывать метод `validate()` внутри конструктора `init`.
. Если родительский тип `ValueObject.Data`:
[arabic]
.. Должен быть (*MUST*) `data class`.
.. Должен иметь (*MUST*) сопутствующий класс `Builder`, реализующий паттерн _Строитель_ (С.м. пример ниже).
.. Должен иметь (*MUST*) метод `toBuilder()`, создающий и возвращающий объект `Builder`.
.. Должен (*MUST*) переопределять метод `fork()` (С.м. пример ниже).
+
[source,kotlin]
----
@Suppress("UNCHECKED_CAST")
override fun <T : Kddd, A : Kddd> fork(vararg args: A): T =
    Builder().apply {
        // инициализация свойств билдера из текущего объекта
    }.build() as T
----
. Если родительский тип `ValueObject.Value`:
[arabic]
.. Должен быть (*MUST*) `value class`
.. Свойство `boxed` должно быть (*MUST*) либо <<pt,*ПТ*>>, либо <<ct,*ТОН*>>.
.. Должен иметь (*MUST*) реализацию билдера в виде оператора `invoke()` в `companion object`:
+
[source,kotlin]
----
public companion object {
    public operator fun invoke(boxed: BoxedType): Cdt = CdtImpl(boxed)
}
----
.. Должен (*MUST*) переопределять метод `fork()`:
+
[source,kotlin]
----
@Suppress("UNCHECKED_CAST")
override fun <T : ValueObject.Value<BoxedType>> fork(boxed: BoxedType): T = CdtImpl(boxed) as T

----
. Должен (*SHOULD*) переопределять метод `validate()`, который будет вызываться перед созданием объекта. В нем пишется логика проверки валидности свойств и параметров и выкидывается IllegalStateException в случае непрохождения проверки. Может быть (*MAY*) пустым, если логика валидации не задана.

=== DSL
В режиме DSL предусмотрено два варианта инициализации свойств простых типов `ValueObject.Value<BOXED : Any>`, где `boxed` является <<ct,*ТОН*>>: непосредственно объектом типа `BOXED`, либо через десериализацию его строкового представления. Во втором случае в имплемениации <<cdt,*CDT*>> должен быть (*MUST*) реализован метод `parse()` в `companion object`, который десериализует объект <<ct,*ТОН*>> и возвращает (абстракцию) тип <<cdt,*CDT*>>:
[source,kotlin]
----
public companion object {
    public fun parse(src: String): Cdt =
        CdtImpl(/* Создать объект 'ТОН' из строки `src` */)
}
----
Для остальных типов — `ValueObject.Data` и `IEntity`, <<cdt,*CDT*>> должен иметь (*MUST*) сопутствующий класс `DslBuilder`, который:

. Должен иметь (*MUST*) список свойств, соответствующий списку свойств <<cdt,*CDT*>>.
. Свойства должны быть (*MUST*) мутабельными (`var`).
[arabic]
.. Свойства со скалярным типом (не коллекции) должны быть (*MUST*) нуллабельными и инициализированы значением `null`.
.. Свойства с типом коллекций должны иметь (*MUST*) соответствущий мутабельный тип (`MutableSet`, `MutableList`, `MutableMap`) и инициализированы пустыми коллекциями (`emptySet()`, `emptyList()`, `emptyMap()`). Вложенные коллекции в качестве параметризованного типа также должны быть мутабельными.
.. Свойства, у которых тип соответствующего свойства <<cdt,*CDT*>> является наследником `ValueObject.Value<BOXED : Any>` и `BOXED` является <<pt,*ПТ*>>, должны иметь (*MUST*) тип `BOXED`. Тоже относится и к параметризованым типам коллекций (С.м. пример).
.. Свойства, у которых тип соответствующего свойства <<cdt,*CDT*>> является наследником `ValueObject.Value<BOXED : Any>` и `BOXED` является <<ct,*ТОН*>>, могут иметь (*MAY*) тип либо `BOXED`, либо `String`, в зависимости от варианта DSL. Тоже относится и к параметризованым типам коллекций (С.м. пример).

. Должен иметь (*MUST*) метод `build()`, создающий и возвращающий (абстракцию) тип <<cdt,*CDT*>>.
[arabic]
.. Метод `build()` должен иметь (*MUST*) проверку на ненуллабельность для свойств с ненуллабельными типами.

=== JSON

== Примеры
.Пример спроектированного <<cdt,*CDT*>> для моделирования точки с двумя координатами.
[source,kotlin]
----
interface Point : ValueObject.Data {
    val x: Coordinate
    val y: Coordinate

    override fun validate() {
        // Здесь можно задать границы модели и провалидировать консистентность свойств.
        check(x.boxed in 0..1000)
        check(y.boxed in 0..1000)
    }

    operator fun plus(other: Point): Point =
        fork(x + other.x, y + other.y)

    operator fun minus(other: Point): Point =
        fork(x - other.x, y - other.y)

    operator fun times(other: Point): Point =
        fork(x * other.x, y * other.y)

    interface Coordinate : ValueObject.Value<Int> {
        override fun validate() {}

        operator fun plus(other: Coordinate): Coordinate =
            fork(boxed + other.boxed)

        operator fun minus(other: Coordinate): Coordinate =
            fork(boxed - other.boxed)

        operator fun times(other: Coordinate): Coordinate =
            fork(boxed * other.boxed)
    }

    interface Distance : ValueObject.Value<Double> {
        override fun validate() {
            check(boxed >= 0)
        }
    }
}
----
.Пример имплементации <<cdt,*CDT*>>.
[source,kotlin]
----
@ConsistentCopyVisibility
data class PointImpl private constructor(
    override val x: Point.Coordinate,
    override val y: Point.Coordinate
) : Point {
    init {
        validate()
    }

    @Suppress("UNCHECKED_CAST")
    override fun <T : Kddd, A : Kddd> fork(vararg args: A): T =
        Builder().apply {
            x = args[0] as Point.Coordinate
            y = args[1] as Point.Coordinate
        }.build() as T

    @JvmInline
    value class CoordinateImpl private constructor(
        override val boxed: Int,
    ) : Point.Coordinate {
        init {
            validate()
        }

        override fun toString(): String =
            boxed.toString()

        @Suppress("UNCHECKED_CAST")
        override fun <T : ValueObject.Boxed<Int>> fork(boxed: Int): T =
            CoordinateImpl(boxed) as T

        companion object {
            operator fun invoke(boxed: Int): Point.Coordinate = CoordinateImpl(boxed)
        }
    }

    @JvmInline
    value class DistanceImpl private constructor(
        override val boxed: Double
    ) : Point.Distance {
        init {
            validate()
        }

        override fun toString(): String =
            boxed.toString()

        @Suppress("UNCHECKED_CAST")
        override fun <T : ValueObject.Value<Double>> fork(boxed: Double): T =
            DistanceImpl(boxed) as T

        companion object {
            operator fun invoke(value: Double): Point.Distance =
                DistanceImpl(value)
        }
    }

    class Builder {
        var x: Point.Coordinate? = null
        var y: Point.Coordinate? = null

        fun build(): Point {
            checkNotNull(x) { "Property 'PointImpl.x' is not set!" }
            checkNotNull(y) { "Property 'PointImpl.y' is not set!" }
            return PointImpl(x!!, y!!)
        }
    }
}
----
.Функции-расширения.
[source,kotlin]
----
fun Point.toBuilder(): PointImpl.Builder =
    PointImpl.Builder().apply {
        x = this@toBuilder.x
        y = this@toBuilder.y
    }

fun Point.asString(): String =
    "(${x.boxed},${y.boxed})"
----
Также в этом интерфейсе можно определить, например, метод расчета расстояния до другой точки или вынести такой функционал этой модели в функцию-расширение как _use case_ и покрыть юнит-тестом.

.Use Case
[source,kotlin]
----
infix fun Result<Point>.`distance to`(other: Result<Point>): Result<Point.Distance> =
    mapCatching { src ->
        (src - other.getOrThrow())
            .let { it * it }
            .let { it.x + it.y }
            .let { sqrt(it.boxed.toDouble()) }
            .let { PointImpl.DistanceImpl(it) }
    }
----
.Применение
[source,kotlin]
----
val point1 = runCatching {
    PointImpl.Builder().apply {
        x = PointImpl.CoordinateImpl(10)
        y = PointImpl.CoordinateImpl(14)
    }.build()
}

val point2 = runCatching {
    PointImpl.Builder().apply {
        x = PointImpl.CoordinateImpl(100)
        y = PointImpl.CoordinateImpl(200)
    }.build()
}

runCatching {
    point1.getOrThrow().asString() to point2.getOrThrow().asString()
}
    .onSuccess { println("point1: ${it.first}, point2: ${it.second}") }
    .onFailure { println("error: ${it.message}") }

(point1 `distance to` point2)
    .onSuccess { println("distance: $it") }
    .onFailure { println("error: ${it.message}") }
----

[glossary]
[#domain-model]
== Термины и определения
МПО:: Модель Предметной Области (Domain Model) — совокупность типов данных и их функционала. https://martinfowler.com/eaaCatalog/domainModel.html[Определение по М. Фаулеру].
[#user]
Пользователь:: Разработчик (бизнес-аналитик, архитектор), использующий данную библиотеку для проектирования собственных типов (*CDT*) для некоторого своего домена.
[#fst]
ФСТ:: Формальная система типов, построенная на заданной аксиоматике — постулатах, определяющих допустимые границы значений и операции над типами.
[#pt]
ПТ:: Примитивный тип Котлин: `String`, `Int`, `Boolean`, и т.д.
[#ct]
ТОН:: Тип общего назначения из стандартных пакетов Java и Котлин, не требующих подключения специальных зависимостей: `File`, `UUID`, `URI`, и т.д.
[#kddd]
Kddd:: Корневой тип библиотеки `KDDD`.
[#cdt]
CDT:: Customer Domain Type — проектируемый *Пользователем* собственный тип структуры данных.
