= Библиотека KDDD
Tepex <tepex@mail.ru>
1.0, 29/V-2025
:source-highliter: rouge
:mmdc: ./node_modules/.bin/mmdc
:toc:
:toc-title: Содержание

KDDD (Kotlin DDD) — библиотека базовых типов, предназначенная для построения <<domain-model,моделей предметных областей>> на языке Котлин согласно с тактическими _DDD_-патернами — _Entity_ и _Value Object_. Состоит из закрытой <<fst,*ФСТ*>>, аннотаций и регламента построения <<cdt,*CDT*>>.

== Мотивация
[quote,Закон Е. А. Седова]
В сложной иерархически организованной системе рост разнообразия на верхнем уровне обеспечивается ограничением разнообразия на предыдущих уровнях, и наоборот, рост разнообразия на нижнем уровне разрушает верхний уровень организации (то есть, система как таковая гибнет).

Котлин является языком программирования общего назначения, предоставляющий очень широкие возможности для разработчика. В частности, — для проектирования собственных структур данных (типов). К сожалению, такая широта зачастую оборачивается появлением порочных практик, таких как мутабельность публичных свойств, одержимость примитивами (_primitive obsession_), нарушениями принципов _SOLID_ и пр.

При проектировании <<domain-model,*МПО*>> необходимо создать собственную <<fst,*ФСТ*>> с  обусловленными бизнес-требованиями правилами и ограничениями, возможностью валидации объектов при их создании, покрытию юнит-тестами логики <<domain-model,*МПО*>>. В свою очередь такая <<fst,*ФСТ*>> должна создаваться в рамках аксиоматики базовой <<fst,*ФСТ*>> высшего уровня, как основы, и которая бы воплощала концепцию тактических _DDD_-патернов — _Entity_ и _Value Object_.

Ограничения должны применяться на самых ранних этапах. Отчасти это возможно решить на уровне компиляции путем создания контрактов (абстрактых методов) в базовых интерфейсах и проверкой их логики юнит-тестами. Отчасти — наличием регламента, задающим эти ограничения. Проверка соблюдения регламента может осуществляться за счет дополнительных инструментов автоматизации: валидаторы кода, линтеры, кодогенераторы.

== Цель
- Создание закрытой базовой <<fst,*ФСТ*>>, воплощающую концепцию тактических _DDD_-патернов.
- Обеспечение механизма валидации <<cdt,*CDT*>> при создании объектов.
- Создание регламента проектирования <<cdt,*CDT*>>.

[#types]
== Базовая *ФСТ*
Интерфейсы <<kddd,*Kddd*>> наследуются от корневого sealed-интерфейса `Kddd` который имеет метод `validate()` предназначенный для валидации объектов при их создании. В переопределенных методах `validate()` должна реализовываться логика валидации объекта и выкидываться исключение `IllegalStateException` в рамках этой логики.

=== `IEntity : Kddd`
Определяет тактический _DDD_-патерн _Entity_. Содержит поля:

- `id` — идентичность сущности.
- `content` — _Value Object_ содержимого сущности.

<<regulation,*Регламент*>> требует, что реализация этого интерфейса должна переопределять контракт `hashCode()/equals()`, завязав их на поле `id`. Отдельная группировка свойств сущности в свойство `content` обусловлена подходом, обоснованным у https://enterprisecraftsmanship.com/posts/nesting-value-object-inside-entity/[Вдадимира Хорикова].

=== `ValueObject : Kddd`
Определяет тактический _DDD_-патерн _Value Object_. Sealed-интерфейс со следующими наследниками:

==== `ValueObject.Data`
Предназначен для проектирования <<cdt,*CDT*>> с несколькими свойствами и последующей имплементации <<cdt,*CDT*>> в виде `data class`. Декларирует метод `<T: Kddd, A: Kddd> fork(vararg args: A): T` для возможности копирования объекта этого типа и аналогичен методу `copy()` у `data class`. Реализация этого метода описана в <<regulation,*Регламенте*>>.

==== `ValueObject.Value<BOXED: Any>`
Предназначен для проектирования *CDT* с одним свойством и последующей имплементации <<cdt,*CDT*>> в виде `value class`. Тип свойства определяется параметризованным типом `BOXED` и может быть либо <<pt,*ПТ*>>, либо <<ct,*ТОН*>>. Обусловлено борьбой с _одержимостью примитивами_. Декларирует метод `<T : Value<BOXED>> fork(boxed: BOXED): T` для возможности копирования объекта этого типа и аналогичен методу `copy()` у `data class`. Реализация этого метода описана в <<regulation,*Регламенте*>>.

Метод `fork()` в контрактах интерфейсов `ValueObject` призван обеспечить возможность создания функционала/операций над этими типами на этапе декларации интерфейсов и, соответственно, компиляции, что обеспечивает возможность сразу создавать и запускать юнит-тесты с соответств прежде, чем будут .

[#annotations]
== Аннотации


public annotation class KDGeneratable(
val implementationName: String = "",
val dsl: Boolean = true,
val json: Boolean = false,
)


[#regulation]
== Регламент
IMPORTANT: Слова «*MUST*», «*MUST NOT*», «*REQUIRED*», «*SHALL*/*SHOULD*», «*MAY*» и «*OPTIONAL*» в нижеследующих списках понимаются как определено в https://www.ietf.org/rfc/rfc2119.txt[RFC 2119].

<<cdt,*CDT*>> может быть реализован двумя способами:

. Опосредовано через интерфейс-наследник <<kddd,*Kddd*>> и последующей имплементацией в классе.
. Непосредственно как класс-наследник <<kddd,*Kddd*>>.

Первый вариант крайне рекомендуется, т.к. разделение абстракции и имплементации удобно своей гибкостью, использованием _Dependency Injection_, юнит-тестированием и, самое главное, — возможностью кодогенерации имплементации.

=== Интерфейс CDT
Тип <<cdt,*CDT*>> (`Cdt`):

. Должен быть (*MUST*) `interface`.
. Должен (*MUST*) наследоваться от соответствующего подтипа <<kddd,*Kddd*>>.
. Свойства не должны быть (*MUST NOT*) мутабельными, быть: `val`. Мутабельность осуществляется через метод `fork()`.
. Свойства могут быть (*MAY*) нуллабельными.
. Если родительский тип `ValueObject.Data`:
[arabic]
.. Свойства должны быть (*MUST*) типом <<cdt,*CDT*>>, либо коллекциями (`Set`, `List`, `Map`) [TODO: еще и `enum`].
.. Параметризованные типы коллекций должны быть (*MUST*) типом <<cdt,*CDT*>>, либо коллекциями с параметризованными типами. Таким образом возможна вложенность коллекций, например: `List<Map<Cdt, Set<Cdt>>` и т.д.
.. Типы свойств могут быть (*MAY*) определены в отдельном <<cdt,*CDT*>>, либо внутри данного типа (_nested_).
. Если родительский тип `ValueObject.Value<BOXED : Any>`:
[arabic]
.. Параметризованный тип должен быть (*MUST*) либо <<pt,*ПТ*>>, либо <<ct,*ТОН*>>.
. Должен (*SHOULD*) переопределять метод `validate()`, который будет вызываться перед созданием объекта. В нем пишется логика проверки валидности свойств и параметров и выкидывается `IllegalStateException` в случае непрохождения проверки. Может быть (*MAY*) пустым, если логика валидации не задана.
. Может (*MAY*) содержать методы, декларирующие/реализующие функционал модели.
. Может (*OPTIONAL*) предваряться `KDDD`-аннотациями.

=== Имплементация *CDT*
Тип <<cdt,*CDT*>> (`CdtImpl`):

. Должен быть (*MUST*) классом-наследником типов <<kddd,*Kddd*>> прямо или опосредовано через интерфейс <<cdt,*CDT*>>.
. Должен иметь (*MUST*) приватный конструктор. Объект класса создается через билдер.
. Должен (*MUST*) вызывать метод `validate()` внутри конструктора `init`.
. Если родительский тип `ValueObject.Data`:
[arabic]
.. Должен быть (*MUST*) `data class`.
.. Должен иметь (*MUST*) сопутствующий класс `Builder`, реализующий паттерн _Строитель_ (С.м. пример ниже).
.. Должен иметь (*MUST*) метод `toBuilder()`, создающий и возвращающий объект `Builder`.
.. Должен (*MUST*) переопределять метод `fork()` (С.м. пример ниже).
+
[source,kotlin]
----
@Suppress("UNCHECKED_CAST")
override fun <T : Kddd, A : Kddd> fork(vararg args: A): T =
    Builder().apply {
        // инициализация свойств билдера из текущего объекта
    }.build() as T
----
. Если родительский тип `ValueObject.Value`:
[arabic]
.. Должен быть (*MUST*) `value class`
.. Свойство `boxed` должно быть (*MUST*) либо <<pt,*ПТ*>>, либо <<ct,*ТОН*>>.
[arabic]
... Если свойство `boxed` является <<ct,*ТОН*>>, то должен иметь (*MUST*) метод `parse()` в `companion object`, который десериализует объект <<ct,*ТОН*>>:
+
[source,kotlin]
----
public companion object {
    public fun parse(src: String): CdtImpl =
        CdtImpl(/* Создать объект 'ТОН' из строки `src` */)
----
.. Должен иметь (*MUST*) реализацию билдера в виде оператора `invoke()` в `companion object`:
+
[source,kotlin]
----
public companion object {
    public operator fun invoke(boxed: BoxedType): Cdt = CdtImpl(boxed)
}
----
.. Должен (*MUST*) переопределять метод `fork()`:
+
[source,kotlin]
----
@Suppress("UNCHECKED_CAST")
override fun <T : ValueObject.Value<BoxedType>> fork(boxed: BoxedType): T = CdtImpl(boxed) as T

----
. Должен (*SHOULD*) переопределять метод `validate()`, который будет вызываться перед созданием объекта. В нем пишется логика проверки валидности свойств и параметров и выкидывается IllegalStateException в случае непрохождения проверки. Может быть (*MAY*) пустым, если логика валидации не задана.

== Примеры
.Пример спроектированного <<cdt,*CDT*>> для моделирования точки с двумя координатами.
[source,kotlin]
----
public interface Point : ValueObject.Data {
    public val x: Coordinate
    public val y: Coordinate

    override fun validate() {
        // Здесь можно задать границы модели и провалидировать консистентность свойств.
        check(x.boxed in 0..1000)
        check(y.boxed in 0..1000)
    }

    public operator fun plus(other: Point): Point =
        fork(x + other.x, y + other.y)

    public operator fun minus(other: Point): Point =
        fork(x - other.x, y - other.y)

    public operator fun times(other: Point): Point =
        fork(x * other.x, y * other.y)

    public interface Coordinate : ValueObject.Value<Int> {
        override fun validate() {}

        public operator fun plus(other: Coordinate): Coordinate =
            fork(boxed + other.boxed)

        public operator fun minus(other: Coordinate): Coordinate =
            fork(boxed - other.boxed)

        public operator fun times(other: Coordinate): Coordinate =
            fork(boxed * other.boxed)
    }
}
----
.Пример имплементации <<cdt,*CDT*>>.
[source,kotlin]
----
@ConsistentCopyVisibility
public data class PointImpl private constructor(
    override val x: Point.Coordinate,
    override val y: Point.Coordinate
) : Point {
    init {
        validate()
    }

    @Suppress("UNCHECKED_CAST")
    override fun <T : Kddd, A : Kddd> fork(vararg args: A): T {
        val ret = Builder().apply {
            x = args[0] as Point.Coordinate
            y = args[1] as Point.Coordinate
        }.build() as T
        return ret
    }

  public fun Point.toBuilder(): PointImpl.Builder {
    val ret = PointImpl.Builder()
    ret.x = x
    ret.y = y
    return ret
  }

  @JvmInline
  public value class CoordinateImpl private constructor(
    override val boxed: Int,
  ) : Point.Coordinate {
    init {
      validate()
    }
    override fun toString(): String = boxed.toString()

    @Suppress("UNCHECKED_CAST")
    override fun <T : ValueObject.Boxed<Int>> fork(boxed: Int): T = CoordinateImpl(boxed) as T

    public companion object {
      public operator fun invoke(boxed: Int): Point.Coordinate = CoordinateImpl(boxed)
    }
  }

  public class Builder {
    public lateinit var x: Point.Coordinate

    public lateinit var y: Point.Coordinate

    public fun build(): PointImpl {
      require(::x.isInitialized) { "Property 'PointImpl.x' is not set!" }
      require(::y.isInitialized) { "Property 'PointImpl.y' is not set!" }
      return PointImpl(x = x,y = y,)
    }
  }
}
----
Также в этом интерфейсе можно определить, например, метод расчета расстояния до другой точки или вынести такой функционал этой модели в функцию-расширение как _use case_ и покрыть юнит-тестом.

[glossary]
[#domain-model]
== Термины и определения
МПО:: Модель Предметной Области (Domain Model) — совокупность типов данных и их функционала. https://martinfowler.com/eaaCatalog/domainModel.html[Определение по М. Фаулеру].
[#user]
Пользователь:: Разработчик, использующий данную библиотеку для проектирования собственных типов (*CDT*) для некоторого своего домена.
[#fst]
ФСТ:: Формальная система типов, построенная на заданной аксиоматике — постулатах, определяющих допустимые границы значений и операции над типами.
[#pt]
ПТ:: Примитивный тип Котлин: `String`, `Int`, `Boolean`, и т.д.
[#ct]
ТОН:: Тип общего назначения из стандартных пакетов Java и Котлин, не требующих подключения специальных зависимостей: `File`, `UUID`, `URI`, и т.д.
[#kddd]
Kddd:: Корневой тип библиотеки `KDDD`.
[#cdt]
CDT:: Customer Domain Type — проектируемый *Пользователем* собственный тип структуры данных.
